{"version":3,"file":"RoomDB.min.js","sources":["../src/parse.js","../src/AbstractClient.js","../src/terms.js","../src/LocalClient.js","../src/Fact.js","../src/RoomDB.js"],"sourcesContent":["'use strict'\n\nconst ohm = require('ohm-js')\n\nconst grammar = ohm.grammar(`\n  G {\n\n    factOrPattern\n      = term*\n\n    term\n      = id\n      | word\n      | value\n      | variable\n      | wildcard\n      | hole\n\n    id\n      = \"#\" alnum*\n\n    value\n      = keyword<\"true\">   -- true\n      | keyword<\"false\">  -- false\n      | keyword<\"null\">   -- null\n      | number\n      | string\n\n    variable\n      = \"$\" alnum+\n\n    wildcard\n      = \"$\"\n\n    hole\n      = \"_\"\n\n    word\n      = (~special any)+  -- nonspace\n      | space+           -- space\n\n    keyword<k>\n      = k ~alnum\n\n    number\n      = float (\"e\" float)?\n\n    float\n      = integer (\".\" digit+)?\n\n    integer\n      = (\"+\" | \"-\")? digit+\n\n    string\n      = \"\\\\\"\" (~\"\\\\\"\" ~\"\\\\n\" any)* \"\\\\\"\"\n\n    special\n      = id | value | variable | wildcard | hole | space\n\n  }\n`)\n\nconst semantics = grammar.createSemantics().addOperation('parse', {\n  factOrPattern (terms) {\n    return terms.parse()\n  },\n  id (_, cs) {\n    return { id: cs.sourceString }\n  },\n  value_true (_) {\n    return { value: true }\n  },\n  value_false (_) {\n    return { value: false }\n  },\n  value_null (_) {\n    return { value: null }\n  },\n  variable (_, cs) {\n    return { variable: cs.sourceString }\n  },\n  wildcard (_) {\n    return { wildcard: true }\n  },\n  hole (_) {\n    return { hole: true }\n  },\n  word_nonspace (_) {\n    return { word: this.sourceString }\n  },\n  word_space (_) {\n    return { word: ' ' }\n  },\n  number (_1, _2, _3) {\n    return { value: parseFloat(this.sourceString) }\n  },\n  string (_oq, cs, _cq) {\n    const chars = []\n    let idx = 0\n    cs = cs.parse()\n    while (idx < cs.length) {\n      let c = cs[idx++]\n      if (c === '\\\\' && idx < cs.length) {\n        c = cs[idx++]\n        switch (c) {\n          case 'n':\n            c = '\\n'\n            break\n          case 't':\n            c = '\\t'\n            break\n          default:\n            idx--\n        }\n      }\n      chars.push(c)\n    }\n    return { value: chars.join('') }\n  },\n  _terminal () {\n    return this.sourceString\n  }\n})\n\nexport default function parse (str, optRule) {\n  const rule = optRule || 'factOrPattern'\n  const matchResult = grammar.match(str.trim(), rule)\n  if (matchResult.succeeded()) {\n    return semantics(matchResult).parse()\n  } else {\n    throw new Error(`invalid ${rule}: ${str}`)\n  }\n}\n","'use strict'\n\nimport parse from './parse'\n\nconst MAX_PARSE_CACHE_SIZE = 1000\n\nexport default class AbstractClient {\n  constructor (id) {\n    this._id = id\n    this._parseCache = new Map()\n    this._asserts = []\n    this._retracts = []\n  }\n\n  assert (factString, ...fillerValues) {\n    const fact = this._toJSONFactOrPattern(factString, ...fillerValues)\n    this._asserts.push(fact)\n  }\n\n  retract (patternString, ...fillerValues) {\n    const pattern = this._toJSONFactOrPattern(patternString, ...fillerValues)\n    this._retracts.push(pattern)\n  }\n\n  async flushChanges () {\n    throw new Error('subclass responsibility')\n  }\n\n  async immediatelyAssert (factString, ...fillerValues) {\n    this.assert(factString, ...fillerValues)\n    await this.flushChanges()\n  }\n\n  async immediatelyRetract (patternString, ...fillerValues) {\n    this.retract(patternString, ...fillerValues)\n    await this.flushChanges()\n  }\n\n  async immediatelyRetractEverythingAbout (name) {\n    throw new Error('subclass responsibility')\n  }\n\n  async immediatelyRetractEverythingAssertedByMe () {\n    throw new Error('subclass responsibility')\n  }\n\n  async getAllFacts () {\n    throw new Error('subclass responsibility')\n  }\n\n  _toJSONFactOrPattern (factOrPatternString, ...fillerValues) {\n    if (arguments.length === 0) {\n      throw new Error('not enough arguments!')\n    }\n    if (typeof factOrPatternString !== 'string') {\n      throw new Error('factOrPatternString must be a string!')\n    }\n    let terms = this._parse(factOrPatternString)\n    if (fillerValues.length > 0) {\n      terms = terms.slice()\n    }\n    for (let idx = 0; idx < terms.length; idx++) {\n      const term = terms[idx]\n      if (term.hasOwnProperty('hole')) {\n        if (fillerValues.length === 0) {\n          throw new Error('not enough filler values!')\n        }\n        terms[idx] = this._toJSONTerm(fillerValues.shift())\n      }\n    }\n    if (fillerValues.length > 0) {\n      throw new Error('too many filler values!')\n    }\n    return terms\n  }\n\n  _toJSONTerm (value) {\n    return { value: value }\n  }\n\n  _parse (factOrPatternString) {\n    if (this._parseCache.has(factOrPatternString)) {\n      return this._parseCache.get(factOrPatternString)\n    } else {\n      this._clearParseCacheIfTooBig()\n      const terms = parse(factOrPatternString)\n      this._parseCache.set(factOrPatternString, terms)\n      return terms\n    }\n  }\n\n  _clearParseCacheIfTooBig () {\n    if (this._parseCache.size > MAX_PARSE_CACHE_SIZE) {\n      this.clearParseCache()\n    }\n  }\n\n  clearParseCache () {\n    this._parseCache.clear()\n  }\n}\n","'use strict'\n\nclass Term {\n  toString () {\n    throw new Error('subclass responsibility')\n  }\n\n  toJSON () {\n    throw new Error('subclass responsibility')\n  }\n\n  toRawValue () {\n    throw new Error('subclass responsibility')\n  }\n\n  match (that, env) {\n    throw new Error('subclass responsibility')\n  }\n}\n\nTerm.fromJSON = json => {\n  if (json.hasOwnProperty('id')) {\n    return new Id(json.id)\n  } else if (json.hasOwnProperty('word')) {\n    return new Word(json.word)\n  } else if (json.hasOwnProperty('value')) {\n    return new Value(json.value)\n  } else if (json.hasOwnProperty('blobRef')) {\n    return new BlobRef(json.blobRef)\n  } else if (json.hasOwnProperty('variable')) {\n    return new Variable(json.variable)\n  } else if (json.hasOwnProperty('wildcard')) {\n    return new Wildcard()\n  } else if (json.hasOwnProperty('hole')) {\n    return new Hole()\n  } else {\n    throw new Error('unrecognized JSON term: ' + JSON.stringify(json))\n  }\n}\n\nclass Id extends Term {\n  constructor (name) {\n    super()\n    this.name = name\n  }\n\n  toString () {\n    return '#' + this.name\n  }\n\n  toJSON () {\n    return { id: this.name }\n  }\n\n  toRawValue () {\n    return this\n  }\n\n  match (that, env) {\n    return that instanceof Id && this.name === that.name ? env : null\n  }\n}\n\nclass Word extends Term {\n  constructor (value) {\n    super()\n    this.value = value\n  }\n\n  toString () {\n    return this.value\n  }\n\n  toJSON () {\n    return { word: this.value }\n  }\n\n  toRawValue () {\n    return this\n  }\n\n  match (that, env) {\n    return that instanceof Word && this.value === that.value ? env : null\n  }\n}\n\nclass Value extends Term {\n  constructor (value) {\n    super()\n    this.value = value\n  }\n\n  toString () {\n    return JSON.stringify(this.value)\n  }\n\n  toJSON () {\n    return { value: this.value }\n  }\n\n  toRawValue () {\n    return this.value\n  }\n\n  match (that, env) {\n    return that instanceof Value && this.value === that.value ? env : null\n  }\n}\n\nclass BlobRef extends Term {\n  constructor (id) {\n    super()\n    this.id = id\n  }\n\n  toString () {\n    return '@' + this.id\n  }\n\n  toJSON () {\n    return { blobRef: this.id }\n  }\n\n  toRawValue () {\n    return this\n  }\n\n  match (that, env) {\n    return that instanceof BlobRef && this.id === that.id ? env : null\n  }\n}\n\nclass Variable extends Term {\n  constructor (name) {\n    super()\n    this.name = name\n  }\n\n  toString () {\n    return '$' + this.name\n  }\n\n  toJSON () {\n    return { variable: this.name }\n  }\n\n  toRawValue () {\n    throw new Error(\"Variable's toRawValue() should never be called!\")\n  }\n\n  match (that, env) {\n    if (env[this.name] === undefined) {\n      env[this.name] = that\n      return env\n    } else {\n      return env[this.name].match(that, env)\n    }\n  }\n}\n\nclass Wildcard extends Term {\n  constructor () {\n    super()\n    // no-op\n  }\n\n  toString () {\n    return '$'\n  }\n\n  toJSON () {\n    return { wildcard: true }\n  }\n\n  toRawValue () {\n    throw new Error(\"Wildcard's toRawValue() should never be called!\")\n  }\n\n  match (that, env) {\n    return env\n  }\n}\n\nclass Hole extends Term {\n  constructor () {\n    super()\n    // no-op\n  }\n\n  toString () {\n    return '_'\n  }\n\n  toJSON () {\n    return { hole: true }\n  }\n\n  toRawValue () {\n    throw new Error(\"Hole's toRawValue() should never be called!\")\n  }\n\n  match (that, env) {\n    throw new Error(\"Hole's match() should never be called!\")\n  }\n}\n\nexport { Term, Id, Word, Value, BlobRef, Variable, Wildcard, Hole }\n","'use strict'\n\nimport AbstractClient from './AbstractClient'\nimport { Term } from './terms'\n\nexport default class LocalClient extends AbstractClient {\n  constructor (db, id) {\n    super(id)\n    this._db = db\n  }\n\n  /**\n   * @param [`selectstring`, `another`] select string\n   * @param callback callback\n   */\n\n  subscribe (patterns, callback) {\n    if (typeof patterns === 'string') patterns = [patterns]\n    const jsonPatterns = patterns.map(patternString =>\n      this._toJSONFactOrPattern(patternString)\n    )\n    return this._db.on(JSON.stringify(jsonPatterns), callback)\n  }\n\n  select (...patternStrings) {\n    const patterns = patternStrings.map(\n      p =>\n        p instanceof Array\n          ? this._toJSONFactOrPattern(...p)\n          : this._toJSONFactOrPattern(p)\n    )\n    const solutions = this._db.select(...patterns)\n    const results = {\n      async doAll (callbackFn) {\n        await callbackFn(solutions)\n        return results\n      },\n      async do (callbackFn) {\n        for (let solution of solutions) {\n          for (let name in solution) {\n            // force serialization and deserialization to simulate going over the network\n            const json = JSON.parse(JSON.stringify(solution[name]))\n            solution[name] = Term.fromJSON(json).toRawValue()\n          }\n          await callbackFn(solution)\n        }\n        return results\n      },\n      async count () {\n        return solutions.length\n      },\n      async isEmpty () {\n        return solutions.length === 0\n      },\n      async isNotEmpty () {\n        return solutions.length > 0\n      }\n    }\n    return results\n  }\n\n  async flushChanges () {\n    this._retracts.forEach(pattern => this._db.retract(this._id, pattern))\n    this._retracts = []\n    this._asserts.forEach(fact => this._db.assert(this._id, fact))\n    this._asserts = []\n  }\n\n  async immediatelyRetractEverythingAbout (name) {\n    return this._db.retractEverythingAbout(this._id, name)\n  }\n\n  async immediatelyRetractEverythingAssertedByMe () {\n    return this._db.retractEverythingAssertedBy(this._id)\n  }\n\n  async getAllFacts () {\n    return this._db.getAllFacts()\n  }\n\n  toString () {\n    return `[LocalClient ${this._id}]`\n  }\n}\n\nmodule.exports = LocalClient\n","'use strict'\n\nimport { Term, Variable, Wildcard } from './terms'\n\nclass Fact {\n  constructor (terms) {\n    this.terms = terms\n  }\n\n  hasVariablesOrWildcards () {\n    return this.terms.some(\n      term => term instanceof Variable || term instanceof Wildcard\n    )\n  }\n\n  match (that, env) {\n    if (this.terms.length !== that.terms.length) {\n      return null\n    }\n    for (let idx = 0; idx < this.terms.length; idx++) {\n      const thisTerm = this.terms[idx]\n      const thatTerm = that.terms[idx]\n      if (!thisTerm.match(thatTerm, env)) {\n        return null\n      }\n    }\n    return env\n  }\n\n  toString () {\n    return this.terms.map(term => term.toString()).join('')\n  }\n}\n\nFact.fromJSON = jsonTerms => {\n  return new Fact(jsonTerms.map(jsonTerm => Term.fromJSON(jsonTerm)))\n}\n\nexport default Fact\n","'use strict'\n\nimport LocalClient from './LocalClient'\nimport { Id } from './terms'\nimport Fact from './Fact'\nimport EventEmitter from 'events'\n\nfunction flatten (obj) {\n  for (let prop in obj) {\n    obj[prop] = obj[prop]\n  }\n  return obj\n}\n\nfunction difference (setA, setB) {\n  let difference = new Set(setA)\n  for (let elem of setB) {\n    difference.delete(elem)\n  }\n  return difference\n}\n\nexport default class RoomDB extends EventEmitter {\n  constructor () {\n    super()\n    this._factMap = new Map()\n    this._subscriptions = new Set()\n\n    this.on('newListener', (jsonPatternsString, callback) => {\n      this._subscriptions.add(jsonPatternsString)\n\n      callback({\n        assertions: this.select(...JSON.parse(jsonPatternsString)),\n        retractions: []\n      })\n    })\n  }\n\n  select (...jsonPatterns) {\n    const patterns = jsonPatterns.map(jsonPattern => Fact.fromJSON(jsonPattern))\n    const solutions = []\n    this._collectSolutions(patterns, Object.create(null), solutions)\n    return solutions.map(flatten)\n  }\n\n  _collectSolutions (patterns, env, solutions) {\n    if (patterns.length === 0) {\n      solutions.push(env)\n    } else {\n      const pattern = patterns[0]\n      for (let fact of this._facts) {\n        const newEnv = Object.create(env)\n        if (pattern.match(fact, newEnv)) {\n          this._collectSolutions(patterns.slice(1), newEnv, solutions)\n        }\n      }\n    }\n  }\n\n  _emitChanges (fn) {\n    const subscriptions = this._subscriptions\n    /**\n     * beforeFacts: {\n     *  '$name is at $x, $y': Set { }\n     * }\n     */\n    const beforeFacts = new Map()\n    subscriptions.forEach(jsonPatternString => {\n      const jsonPatterns = JSON.parse(jsonPatternString)\n      const solutions = this.select(...jsonPatterns)\n      beforeFacts.set(jsonPatternString, new Set(solutions.map(JSON.stringify)))\n    })\n    // assert('gorog is at 1, 2')\n    fn()\n\n    /**\n     * afterFacts: {\n     *  '$name is at $x, $y': Set{ {name: 'gorog', x: 1, y: 2} }\n     * }\n     */\n    const afterFacts = new Map()\n    subscriptions.forEach(jsonPatternString => {\n      const jsonPatterns = JSON.parse(jsonPatternString)\n      const solutions = this.select(...jsonPatterns)\n      afterFacts.set(jsonPatternString, new Set(solutions.map(JSON.stringify)))\n    })\n    /**\n     * {\n     *    assertions: [ {name: 'gorog', x: 1, y: 2} ]\n     * }\n     */\n    subscriptions.forEach(jsonPatternString => {\n      const before = beforeFacts.get(jsonPatternString)\n      const after = afterFacts.get(jsonPatternString)\n\n      const assertions = Array.from(difference(after, before)).map(JSON.parse)\n      const retractions = Array.from(difference(before, after)).map(JSON.parse)\n      if (assertions.length + retractions.length) {\n        this.emit(jsonPatternString, {\n          pattern: jsonPatternString,\n          assertions,\n          retractions\n        })\n      }\n    })\n  }\n\n  assert (...args) {\n    const assert = this._assert.bind(this, ...args)\n    this._emitChanges(assert)\n  }\n\n  _assert (clientId, factJSON) {\n    if (factJSON === undefined) {\n      throw new Error('factJSON is undefined')\n    }\n    const fact = Fact.fromJSON(factJSON)\n\n    if (fact.hasVariablesOrWildcards()) {\n      throw new Error('cannot assert a fact that has variables or wildcards!')\n    }\n    fact.asserter = clientId\n    const a = new Set()\n    a.keys\n    this._factMap.set(fact.toString(), fact)\n  }\n\n  retract (...args) {\n    const retract = this._retract.bind(this, ...args)\n    this._emitChanges(retract)\n  }\n\n  _retract (clientId, factJSON) {\n    const pattern = Fact.fromJSON(factJSON)\n    if (pattern.hasVariablesOrWildcards()) {\n      const factsToRetract = this._facts.filter(fact =>\n        pattern.match(fact, Object.create(null))\n      )\n      factsToRetract.forEach(fact => this._factMap.delete(fact.toString()))\n      return factsToRetract.length\n    } else {\n      return this._factMap.delete(pattern.toString()) ? 1 : 0\n    }\n  }\n\n  retractEverythingAbout (clientId, name) {\n    const id = new Id(name)\n    const emptyEnv = Object.create(null)\n    const factsToRetract = this._facts.filter(fact =>\n      fact.terms.some(term => id.match(term, emptyEnv))\n    )\n    factsToRetract.forEach(fact => this._factMap.delete(fact.toString()))\n    return factsToRetract.length\n  }\n\n  retractEverythingAssertedBy (clientId) {\n    const factsToRetract = this._facts.filter(\n      fact => fact.asserter === clientId\n    )\n    factsToRetract.forEach(fact => this._factMap.delete(fact.toString()))\n    return factsToRetract.length\n  }\n\n  get _facts () {\n    return Array.from(this._factMap.values())\n  }\n\n  getAllFacts () {\n    return this._facts.map(fact => fact.toString())\n  }\n\n  toString () {\n    return this._facts\n      .map(fact => '<' + fact.asserter + '> ' + fact.toString())\n      .join('\\n')\n  }\n\n  client (id = 'local-client') {\n    return new LocalClient(this, id)\n  }\n}\n"],"names":["grammar","require","semantics","createSemantics","addOperation","factOrPattern","terms","parse","id","_","cs","sourceString","value_true","value","value_false","value_null","variable","wildcard","hole","[object Object]","word","this","word_space","_1","_2","_3","parseFloat","_oq","_cq","chars","idx","length","c","push","join","MAX_PARSE_CACHE_SIZE","AbstractClient","_id","_parseCache","Map","_asserts","_retracts","factString","fillerValues","fact","_toJSONFactOrPattern","patternString","pattern","Error","assert","flushChanges","retract","name","factOrPatternString","arguments","_parse","slice","hasOwnProperty","_toJSONTerm","shift","has","get","_clearParseCacheIfTooBig","str","optRule","rule","matchResult","match","trim","succeeded","set","size","clearParseCache","clear","Term","that","env","fromJSON","json","Id","Word","Value","BlobRef","blobRef","Variable","Wildcard","super","JSON","stringify","undefined","LocalClient","db","_db","patterns","callback","jsonPatterns","map","on","patternStrings","p","Array","solutions","select","results","doAll","callbackFn","solution","toRawValue","count","isEmpty","isNotEmpty","forEach","retractEverythingAbout","retractEverythingAssertedBy","getAllFacts","module","exports","Fact","some","term","thisTerm","thatTerm","toString","flatten","obj","prop","difference","setA","setB","Set","elem","delete","jsonTerms","jsonTerm","EventEmitter","_factMap","_subscriptions","jsonPatternsString","add","assertions","retractions","jsonPattern","_collectSolutions","Object","create","_facts","newEnv","fn","subscriptions","beforeFacts","jsonPatternString","afterFacts","before","after","from","emit","args","_assert","bind","_emitChanges","clientId","factJSON","hasVariablesOrWildcards","asserter","_retract","factsToRetract","filter","emptyEnv","values"],"mappings":"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"}